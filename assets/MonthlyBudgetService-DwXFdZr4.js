import{d as u,a as d,g as w,t as i,T as m,s as f,u as g,b as I,c as B,q as b,e as v,w as E,f as D,h as $,o as q}from"./index-BOgRbC34.js";class p{static instance;static getInstance(){return p.instance||(p.instance=new p),p.instance}async getMonthlyBudget(t,e){try{const o=u(d,"users",t,"monthlyBudgets",e),n=await w(o);if(n.exists()){const a=n.data();return{id:a.id,userId:a.userId,month:a.month,totalIncome:a.totalIncome,availableToBudget:a.availableToBudget,createdAt:i(a.createdAt),updatedAt:i(a.updatedAt)}}return null}catch(o){throw console.error("Error getting monthly budget:",o),o}}async createOrUpdateMonthlyBudget(t){try{const e=m.now(),o=`${t.userId}_${t.month}`,n={id:o,userId:t.userId,month:t.month,totalIncome:t.totalIncome,availableToBudget:t.availableToBudget,createdAt:e,updatedAt:e};return await f(u(d,"users",t.userId,"monthlyBudgets",t.month),n),{...t,id:o,createdAt:i(e),updatedAt:i(e)}}catch(e){throw console.error("Error creating/updating monthly budget:",e),e}}async getMonthData(t,e){try{if(!await this.getMonthlyBudget(t,e))return{incomeSources:[],allocations:[]};const n=u(d,"users",t,"monthlyBudgets",e),a=await w(n);if(!a.exists())return{incomeSources:[],allocations:[]};const c=a.data(),s=(c.incomeSources||[]).map(r=>({id:r.id,userId:r.userId,month:r.month,name:r.name,amount:r.amount,frequency:r.frequency||"monthly",category:r.category,createdAt:i(r.createdAt),updatedAt:i(r.updatedAt)})),h=Object.entries(c.allocations||{}).map(([r,y])=>({id:r,userId:t,envelopeId:r,month:e,budgetedAmount:y,createdAt:i(c.createdAt),updatedAt:i(c.updatedAt)}));return{incomeSources:s,allocations:h}}catch(o){throw console.error("Error getting month data:",o),o}}async getIncomeSources(t,e){return(await this.getMonthData(t,e)).incomeSources}async createIncomeSource(t){try{const e=m.now(),o=`inc_${e.toMillis()}_${Math.random().toString(36).substr(2,9)}`,n={id:o,userId:t.userId,month:t.month,name:t.name,amount:t.amount,frequency:t.frequency||"monthly",category:t.category,createdAt:e,updatedAt:e},a=u(d,"users",t.userId,"monthlyBudgets",t.month);return await g(a,{incomeSources:I(n)}),{...t,id:o,frequency:t.frequency||"monthly",createdAt:i(e),updatedAt:i(e)}}catch(e){throw console.error("Error creating income source:",e),e}}async getEnvelopeAllocations(t,e){return(await this.getMonthData(t,e)).allocations}async createEnvelopeAllocation(t){try{const e=m.now(),o=u(d,"users",t.userId,"monthlyBudgets",t.month);return await g(o,{[`allocations.${t.envelopeId}`]:t.budgetedAmount,updatedAt:e}),{...t,id:t.envelopeId,createdAt:i(e),updatedAt:i(e)}}catch(e){throw console.error("Error creating envelope allocation:",e),e}}async copyMonthData(t,e,o){try{const n=await this.getMonthData(t,e),a=m.now(),c=n.incomeSources.map(l=>({id:`inc_${a.toMillis()}_${Math.random().toString(36).substr(2,9)}`,userId:t,month:o,name:l.name,amount:l.amount,frequency:l.frequency||"monthly",category:l.category,createdAt:a,updatedAt:a})),s={};n.allocations.forEach(l=>{s[l.envelopeId]=l.budgetedAmount});const h=c.reduce((l,A)=>l+A.amount,0),r=Object.values(s).reduce((l,A)=>l+A,0),S={id:`${t}_${o}`,userId:t,month:o,totalIncome:h,availableToBudget:h-r,createdAt:a,updatedAt:a,allocations:s,incomeSources:c};await f(u(d,"users",t,"monthlyBudgets",o),S)}catch(n){throw console.error("Error copying month data:",n),n}}async deleteIncomeSource(t,e,o){try{const n=u(d,"users",t,"monthlyBudgets",o),a=await w(n);if(!a.exists())return;const h=(a.data().incomeSources||[]).filter(r=>r.id!==e);await g(n,{incomeSources:h,updatedAt:m.now()})}catch(n){throw console.error("Error deleting income source:",n),n}}async updateIncomeSource(t,e,o,n){try{const a=u(d,"users",t,"monthlyBudgets",o),c=await w(a);if(!c.exists())return;const r=(c.data().incomeSources||[]).map(y=>y.id===e?{...y,...n,updatedAt:m.now()}:y);await g(a,{incomeSources:r,updatedAt:m.now()})}catch(a){throw console.error("Error updating income source:",a),a}}async deleteEnvelopeAllocation(t,e,o){try{const n=u(d,"users",t,"monthlyBudgets",o);await g(n,{[`allocations.${e}`]:B(),updatedAt:m.now()})}catch(n){throw console.error("Error deleting envelope allocation:",n),n}}async updateEnvelopeAllocation(t,e,o,n){try{const a=u(d,"users",t,"monthlyBudgets",o);n.budgetedAmount!==void 0&&await g(a,{[`allocations.${e}`]:n.budgetedAmount,updatedAt:m.now()})}catch(a){throw console.error("Error updating envelope allocation:",a),a}}async clearMonthData(t,e){try{const o=u(d,"users",t,"monthlyBudgets",e);await g(o,{totalIncome:0,availableToBudget:0,incomeSources:[],allocations:{},updatedAt:m.now()});const n=b(v(d,"users",t,"transactions"),E("month","==",e)),a=await D(n);if(a.size>0){const c=a.docs.map(s=>$(s.ref));await Promise.all(c),console.log(`ðŸ—‘ï¸ Deleted ${a.size} transactions for month ${e}`)}else console.log(`ðŸ“­ No transactions found for month ${e}`)}catch(o){throw console.error("Error clearing month data:",o),o}}async calculateAvailableToBudget(t,e){try{const o=await this.getMonthData(t,e),n=o.incomeSources.reduce((c,s)=>c+s.amount,0),a=o.allocations.reduce((c,s)=>c+s.budgetedAmount,0);return n-a}catch(o){throw console.error("Error calculating available to budget:",o),o}}subscribeToMonthlyBudget(t,e,o){const n=u(d,"users",t,"monthlyBudgets",e);return q(n,a=>{a.exists()?o(a.data()):o(null)})}}const R=p.getInstance();export{p as MonthlyBudgetService,R as monthlyBudgetService};
