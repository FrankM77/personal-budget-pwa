import{d as i,a as u,g as A,t as l,l as s,T as h,s as S,u as y,b as B,c as b,q as v,e as E,w as D,f as $,h as q,o as M}from"./index-CAk5I03r.js";class w{static instance;static getInstance(){return w.instance||(w.instance=new w),w.instance}async getMonthlyBudget(t,e){try{const o=i(u,"users",t,"monthlyBudgets",e),n=await A(o);if(n.exists()){const a=n.data();return{id:a.id,userId:a.userId,month:a.month,totalIncome:a.totalIncome,availableToBudget:a.availableToBudget,createdAt:l(a.createdAt),updatedAt:l(a.updatedAt)}}return null}catch(o){throw s.error("Error getting monthly budget:",o),o}}async createOrUpdateMonthlyBudget(t){try{const e=h.now(),o=`${t.userId}_${t.month}`,n={id:o,userId:t.userId,month:t.month,totalIncome:t.totalIncome,availableToBudget:t.availableToBudget,createdAt:e,updatedAt:e};return await S(i(u,"users",t.userId,"monthlyBudgets",t.month),n),{...t,id:o,createdAt:l(e),updatedAt:l(e)}}catch(e){throw s.error("Error creating/updating monthly budget:",e),e}}async getMonthData(t,e){try{if(!await this.getMonthlyBudget(t,e))return{incomeSources:[],allocations:[]};const n=i(u,"users",t,"monthlyBudgets",e),a=await A(n);if(!a.exists())return{incomeSources:[],allocations:[]};const c=a.data(),d=(c.incomeSources||[]).map(r=>({id:r.id,userId:r.userId,month:r.month,name:r.name,amount:r.amount,frequency:r.frequency||"monthly",category:r.category,createdAt:l(r.createdAt),updatedAt:l(r.updatedAt)})),g=Object.entries(c.allocations||{}).map(([r,p])=>({id:r,userId:t,envelopeId:r,month:e,budgetedAmount:p,createdAt:l(c.createdAt),updatedAt:l(c.updatedAt)}));return{incomeSources:d,allocations:g}}catch(o){throw s.error("Error getting month data:",o),o}}async getIncomeSources(t,e){return(await this.getMonthData(t,e)).incomeSources}async createIncomeSource(t){try{const e=h.now(),o=`inc_${e.toMillis()}_${Math.random().toString(36).substr(2,9)}`,n={id:o,userId:t.userId,month:t.month,name:t.name,amount:t.amount,frequency:t.frequency||"monthly",category:t.category,createdAt:e,updatedAt:e},a=i(u,"users",t.userId,"monthlyBudgets",t.month);return await y(a,{incomeSources:B(n)}),{...t,id:o,frequency:t.frequency||"monthly",createdAt:l(e),updatedAt:l(e)}}catch(e){throw s.error("Error creating income source:",e),e}}async getEnvelopeAllocations(t,e){return(await this.getMonthData(t,e)).allocations}async createEnvelopeAllocation(t){try{const e=h.now(),o=i(u,"users",t.userId,"monthlyBudgets",t.month);return await y(o,{[`allocations.${t.envelopeId}`]:t.budgetedAmount,updatedAt:e}),{...t,id:t.envelopeId,createdAt:l(e),updatedAt:l(e)}}catch(e){throw s.error("Error creating envelope allocation:",e),e}}async copyMonthData(t,e,o){try{const n=await this.getMonthData(t,e),a=h.now(),c=n.incomeSources.map(m=>({id:`inc_${a.toMillis()}_${Math.random().toString(36).substr(2,9)}`,userId:t,month:o,name:m.name,amount:m.amount,frequency:m.frequency||"monthly",category:m.category,createdAt:a,updatedAt:a})),d={};n.allocations.forEach(m=>{d[m.envelopeId]=m.budgetedAmount});const g=c.reduce((m,f)=>m+f.amount,0),r=Object.values(d).reduce((m,f)=>m+f,0),I={id:`${t}_${o}`,userId:t,month:o,totalIncome:g,availableToBudget:g-r,createdAt:a,updatedAt:a,allocations:d,incomeSources:c};await S(i(u,"users",t,"monthlyBudgets",o),I)}catch(n){throw s.error("Error copying month data:",n),n}}async deleteIncomeSource(t,e,o){try{const n=i(u,"users",t,"monthlyBudgets",o),a=await A(n);if(!a.exists())return;const g=(a.data().incomeSources||[]).filter(r=>r.id!==e);await y(n,{incomeSources:g,updatedAt:h.now()})}catch(n){throw s.error("Error deleting income source:",n),n}}async updateIncomeSource(t,e,o,n){try{const a=i(u,"users",t,"monthlyBudgets",o),c=await A(a);if(!c.exists())return;const r=(c.data().incomeSources||[]).map(p=>p.id===e?{...p,...n,updatedAt:h.now()}:p);await y(a,{incomeSources:r,updatedAt:h.now()})}catch(a){throw s.error("Error updating income source:",a),a}}async deleteEnvelopeAllocation(t,e,o){try{const n=i(u,"users",t,"monthlyBudgets",o);await y(n,{[`allocations.${e}`]:b(),updatedAt:h.now()})}catch(n){throw s.error("Error deleting envelope allocation:",n),n}}async updateEnvelopeAllocation(t,e,o,n){try{const a=i(u,"users",t,"monthlyBudgets",o);n.budgetedAmount!==void 0&&await y(a,{[`allocations.${e}`]:n.budgetedAmount,updatedAt:h.now()})}catch(a){throw s.error("Error updating envelope allocation:",a),a}}async clearMonthData(t,e){try{const o=i(u,"users",t,"monthlyBudgets",e);await y(o,{totalIncome:0,availableToBudget:0,incomeSources:[],allocations:{},updatedAt:h.now()});const n=v(E(u,"users",t,"transactions"),D("month","==",e)),a=await $(n);if(a.size>0){const c=a.docs.map(d=>q(d.ref));await Promise.all(c),s.log(`ðŸ—‘ï¸ Deleted ${a.size} transactions for month ${e}`)}else s.log(`ðŸ“­ No transactions found for month ${e}`)}catch(o){throw s.error("Error clearing month data:",o),o}}async calculateAvailableToBudget(t,e){try{const o=await this.getMonthData(t,e),n=o.incomeSources.reduce((c,d)=>c+d.amount,0),a=o.allocations.reduce((c,d)=>c+d.budgetedAmount,0);return n-a}catch(o){throw s.error("Error calculating available to budget:",o),o}}subscribeToMonthlyBudget(t,e,o){const n=i(u,"users",t,"monthlyBudgets",e);return M(n,a=>{a.exists()?o(a.data()):o(null)})}}const T=w.getInstance();export{w as MonthlyBudgetService,T as monthlyBudgetService};
